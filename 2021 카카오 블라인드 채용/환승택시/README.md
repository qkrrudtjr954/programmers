# 광고 삽입

최단거리 문제인데, 환승 지점에서 각 최단거리를 구하는 문제였다. 완전 탐색을 사용하여 풀었다.

[문제 바로가기 링크](https://programmers.co.kr/learn/courses/30/lessons/72413?language=python3)

## 풀이 순서

1. 각 지점별로 최단으로 갈 수 있는 거리를 구한다.
    1. floyd-warshall 알고리즘을 사용하여 각 노드별 최소 거리를 구함.
2. 각 노드를 환승지점이라고 가정하고, 환승지점에서 A, B 까지 가는 최소 지점을 구한다.
    1. 각 노드를 환증지점으로 정하는 것에서 완전 탐색이라 볼 수 있다.

## 새로 알게 된 점

### floyd-warshall 알고리즘

각 노드에서 노드까지 가는 최단 거릴 초기화할 때, floyd-warshall 알고리즘을 사용했다. 플로이드-워셜 알고리즘은 간선이 갖는 가중치가 음수가 아닌 그래프에서 최단 경로들을 찾을 수 있는 알고리즘이다. 해당 알고리즘을 한 번 수행하면 모든 노드 간의 최단 경로의 길이(가중치의 합)를 구할 수 있다.

```python
n = 5
distances = [
    [0, 100000000, 100000000, 100000000, 100000000, 100000000],
    [100000000, 0, 100000000, 8, 12, 6],
    [100000000, 100000000, 0, 9, 20, 7],
    [100000000, 8, 9, 0, 100000000, 7],
    [100000000, 12, 20, 100000000, 0, 11],
    [100000000, 6, 7, 7, 11, 0]
]

for k in range(n):
    for i in range(n):
        for j in range(n):
            distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])
```

알고리즘을 살펴보면 3중 for 문을 돌고 있는데, 여기서 k가 환승지점이라고 생각하면 된다. 
floyd-warshall 알고리즘을 수행하고 난 다음의 distances 로 **S -> k 까지 간 요금** + **k -> A 까지 간 요금** + **k -> B 까지 간 요금**이 최소가 되는 지점을 찾으면 된다.

```text
[[0, 100000000, 100000000, 100000000, 100000000, 100000000],
 [100000000, 0, 13, 8, 12, 6],
 [100000000, 13, 0, 9, 18, 7],
 [100000000, 8, 9, 0, 18, 7],
 [100000000, 12, 18, 18, 0, 11],
 [100000000, 6, 7, 7, 11, 0]]
```