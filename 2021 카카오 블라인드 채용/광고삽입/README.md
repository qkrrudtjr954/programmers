# 광고 삽입

완전 탐색을 사용해서 풀 수 있는 문제였다.

[문제 바로가기 링크](https://programmers.co.kr/learn/courses/30/lessons/72414?language=python3#)

## 풀이 순서

1. 주어진 시간 문자열을 초로 환산한다.
    1. 동영상 플레이 시간
    2. 광고 시간
    3. 시청 로그 (시청 시작 ~ 시청 종료)
2. 동영상 플레이 시간 만큼 배열을 초기화한다.
    1. 1초 당 시청자의 수를 저장하기 위해서
3. 시청시각을 기준으로 시청자의 수를 배열에 +1 한다.
4. 1초 부터 광고 시간 만큼 배열을 잘라 합을 구한다.
    1. 합이 의미하는 바는 광고 시간동안 시청한 시청자의 수다.
5. 가장 많이 시청한 구간의 시청 시작 시간을 구한다.

## 재밌었던 점

### 숫자 범위 중 겹치는 부분 구하는 방법

풀이 순서 3번에서 시청 시각을 기준으로 시청자의 수를 배열에 +1 할 때, 무턱대고 모든 배열에 1을 더하면 다음과 같이 될 것이다.

```python
동영상_재생시간 = 15
초별_시청자_수 = [0] * (동영상_재생시간 + 1)  # 초기화
시청시각 = [(1, 5), (3, 5), (2, 7), (8, 11), (4, 6), (9, 13)]

for 시청_시작_초, 시청_종료_초 in 시청시각:
    for i in range(시청_시작_초, 시청_종료_초 + 1):
        초별_시청자_수[i] += 1
```

이중 for 문을 돌아 시간 복잡도가 O(N^2)으로 나오게 되는데, 여기서 트릭을 쓰면 O(N)으로 줄일 수 있다.

```python
동영상_재생시간 = 15
초별_시청자_수 = [0] * (동영상_재생시간 + 1)  # 초기화
시청시각 = [(1, 5), (3, 5), (2, 7), (8, 11), (4, 6), (9, 13)]

for 시청_시작_초, 시청_종료_초 in 시청시각:
    초별_시청자_수[시청_시작_초] += 1
    초별_시청자_수[시청_종료_초 + 1] -= 1

for i in range(1, 동영상_재생시간 + 1):
    초별_시청자_수[i] += 초별_시청자_수[i - 1]
```

시청을 시작하는 시간에 시청자 수 +1을 하고, 시청을 다한 시간에 시청자 수 -1을 해준다. 그 다음 배열을 순회하며 n-1 번과 n 번의 값을 더해 n 번의 현재 값을 치환한다. for 문을 하나씩 두번 돌아서 원하는 같은 결과를 얻을 수 있었다.
